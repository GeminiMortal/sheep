<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Áâõ‰∫Ü‰∏™Áâõ</title>
        <script src="https://unpkg.com/vue@3.3.4/dist/vue.global.prod.js"></script>
        <style>
            /* ÂÖ®Â±ÄÊ†∑Âºè */
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                min-height: 100vh;
                display: flex;
                justify-content: center;
                align-items: center;
                color: #333;
            }

            /* Ê∏∏ÊàèÂÆπÂô® */
            .game-container {
                background: white;
                border-radius: 20px;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
                padding: 20px;
                max-width: 800px;
                width: 90%;
                position: relative;
            }

            /* Ê∏∏ÊàèÊ†áÈ¢ò */
            h1 {
                text-align: center;
                color: #667eea;
                margin-bottom: 20px;
                font-size: 36px;
            }

            /* ÂÖ≥Âç°‰ø°ÊÅØ */
            .level-info {
                display: flex;
                justify-content: space-between;
                margin-bottom: 20px;
                font-size: 18px;
                font-weight: bold;
            }

            /* Ê∏∏ÊàèÂå∫Âüü */
            .game-area {
                width: 100%;
                height: 400px;
                background: #f8f9fa;
                border-radius: 15px;
                position: relative;
                overflow: hidden;
                margin-bottom: 20px;
                border: 2px solid #e9ecef;
            }

            /* ÂÖ≥Âç°ÊåáÁ§∫Âô® */
            .level-indicator {
                position: absolute;
                top: 10px;
                left: 10px;
                background: rgba(102, 126, 234, 0.9);
                color: white;
                padding: 5px 15px;
                border-radius: 20px;
                font-weight: bold;
            }

            /* Âç°ÁâáÊ†∑Âºè */
            .card {
                width: 65px;
                height: 85px;
                background: white;
                border-radius: 10px;
                position: absolute;
                display: flex;
                justify-content: center;
                align-items: center;
                font-size: 32px;
                cursor: pointer;
                transition: all 0.3s ease;
                border: 2px solid #ddd;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            }

            .card:hover {
                transform: scale(1.05);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            }

            .card.locked {
                opacity: 0.5;
                cursor: not-allowed;
            }

            .card.matched {
                opacity: 0;
                transform: scale(0.8) rotate(180deg);
            }

            .card.selected {
                transform: scale(1.1);
                border-color: #667eea;
                box-shadow: 0 0 15px rgba(102, 126, 234, 0.5);
            }

            .card.hint-animation {
                animation: hint-pulse 0.5s infinite alternate;
                border-color: #ffc107;
            }

            @keyframes hint-pulse {
                from { transform: scale(1); }
                to { transform: scale(1.1); }
            }

            .card.refreshing {
                animation: refresh-spin 0.5s ease-in-out;
            }

            @keyframes refresh-spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }

            .card.max-clicks {
                border-color: #dc3545;
                background: #f8d7da;
            }

            .card.clicked-once {
                border-color: #fd7e14;
            }

            /* ÁÇπÂáªÊ¨°Êï∞ */
            .click-count {
                position: absolute;
                bottom: 2px;
                right: 4px;
                font-size: 10px;
                background: rgba(0, 0, 0, 0.6);
                color: white;
                padding: 2px 4px;
                border-radius: 4px;
            }

            /* Âç°ÊßΩ */
            .card-slot {
                width: 100%;
                height: 100px;
                background: #e9ecef;
                border-radius: 15px;
                display: flex;
                justify-content: space-around;
                align-items: center;
                padding: 10px;
                margin-bottom: 20px;
                position: relative;
                transition: all 0.3s ease;
            }

            .card-slot.slot-full {
                background: #f8d7da;
                border-color: #dc3545;
                animation: slot-full-pulse 0.5s infinite alternate;
            }

            .card-slot.slot-clearing {
                animation: slot-clear 0.3s ease-out;
            }

            @keyframes slot-full-pulse {
                from { background: #e9ecef; }
                to { background: #f8d7da; }
            }

            @keyframes slot-clear {
                0% { background: #e9ecef; }
                50% { background: #d4edda; }
                100% { background: #e9ecef; }
            }

            /* Âç°ÊßΩÂç°Áâá */
            .slot-card {
                width: 60px;
                height: 80px;
                background: white;
                border-radius: 8px;
                display: flex;
                justify-content: center;
                align-items: center;
                font-size: 28px;
                cursor: pointer;
                border: 2px solid #667eea;
                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
                transition: all 0.2s ease;
            }

            .slot-card:hover {
                transform: scale(1.05);
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            }

            /* ÊéßÂà∂ÊåâÈíÆ */
            .controls {
                display: flex;
                justify-content: space-around;
                gap: 10px;
                margin-bottom: 20px;
            }

            .controls button {
                flex: 1;
                padding: 12px 20px;
                font-size: 16px;
                font-weight: bold;
                background: #667eea;
                color: white;
                border: none;
                border-radius: 10px;
                cursor: pointer;
                transition: all 0.3s ease;
            }

            .controls button:hover:not(:disabled) {
                background: #5a67d8;
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            }

            .controls button:disabled {
                background: #6c757d;
                cursor: not-allowed;
                opacity: 0.6;
            }

            .controls button.secondary {
                background: #17a2b8;
            }

            .controls button.secondary:hover:not(:disabled) {
                background: #138496;
            }

            /* Èü≥‰πêÊéßÂà∂ÊåâÈíÆ */
            .music-control-btn {
                position: absolute;
                top: 20px;
                right: 20px;
                width: 40px;
                height: 40px;
                border-radius: 50%;
                background: #667eea;
                color: white;
                border: none;
                cursor: pointer;
                font-size: 20px;
                display: flex;
                justify-content: center;
                align-items: center;
                transition: all 0.3s ease;
            }

            .music-control-btn:hover {
                background: #5a67d8;
                transform: scale(1.1);
            }

            /* ÊúÄÈ´òÂàÜÊòæÁ§∫ */
            .high-score,
            .global-high-score {
                text-align: center;
                font-size: 16px;
                margin-bottom: 10px;
                font-weight: bold;
            }

            /* Ë¶ÜÁõñÂ±Ç */
            .overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                z-index: 1000;
            }

            /* Ê∂àÊÅØÂºπÁ™ó */
            .message {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: white;
                border-radius: 20px;
                padding: 40px;
                text-align: center;
                z-index: 1001;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
                min-width: 300px;
            }

            .message h2 {
                color: #667eea;
                margin-bottom: 20px;
                font-size: 32px;
            }

            .message p {
                margin-bottom: 30px;
                font-size: 18px;
                color: #6c757d;
            }

            .message button {
                padding: 12px 30px;
                font-size: 18px;
                font-weight: bold;
                background: #667eea;
                color: white;
                border: none;
                border-radius: 10px;
                cursor: pointer;
                transition: all 0.3s ease;
            }

            .message button:hover {
                background: #5a67d8;
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            }

            .message.victory h2 {
                color: #28a745;
            }

            /* Ë°®ÊÉÖÁ¨¶Âè∑ */
            .emoji {
                font-size: 64px;
                margin: 20px 0;
            }

            /* ÂÖ≥Âç°ÂæΩÁ´† */
            .level-badge {
                background: #ffc107;
                color: #212529;
                padding: 8px 16px;
                border-radius: 20px;
                font-weight: bold;
                margin-bottom: 20px;
                display: inline-block;
            }

            /* Êñ∞Á∫™ÂΩïÊ∂àÊÅØ */
            .new-record {
                position: fixed;
                top: 20%;
                left: 50%;
                transform: translateX(-50%);
                padding: 20px 40px;
                border-radius: 15px;
                color: white;
                font-size: 24px;
                font-weight: bold;
                text-align: center;
                z-index: 1002;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                animation: record-popup 0.5s ease-out;
            }

            @keyframes record-popup {
                from {
                    opacity: 0;
                    transform: translate(-50%, -50%);
                }
                to {
                    opacity: 1;
                    transform: translateX(-50%);
                }
            }

            /* Ê∏∏ÊàèÊ∂àÊÅØ */
            .game-message {
                position: fixed;
                top: 50px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 15px 30px;
                border-radius: 25px;
                font-size: 18px;
                z-index: 1001;
                transition: opacity 0.3s ease;
            }

            /* Ê∏∏ÊàèËßÑÂàôÂºπÁ™ó */
            .rules-modal {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1003;
            }

            .rules-content {
                background: white;
                border-radius: 20px;
                padding: 40px;
                max-width: 600px;
                width: 90%;
                max-height: 80vh;
                overflow-y: auto;
                text-align: center;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            }

            .rules-content h2 {
                color: #667eea;
                margin-bottom: 30px;
                font-size: 28px;
            }

            .rules-content ul {
                text-align: left;
                margin-bottom: 30px;
                padding-left: 20px;
            }

            .rules-content li {
                margin-bottom: 15px;
                font-size: 16px;
                line-height: 1.6;
                color: #495057;
            }

            .rules-content button {
                padding: 12px 30px;
                font-size: 18px;
                font-weight: bold;
                background: #667eea;
                color: white;
                border: none;
                border-radius: 10px;
                cursor: pointer;
                transition: all 0.3s ease;
            }

            .rules-content button:hover {
                background: #5a67d8;
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            }
        </style>
    </head>
    <body>
        <div id="app"></div>

        <script>
            const { createApp, ref, reactive, computed, onMounted, nextTick } = Vue

            const app = createApp({
                setup() {
                    // Ê∏∏ÊàèÈÖçÁΩÆ
                    const config = {
                        slots: 7,
                        baseLayers: 3,
                        increaseLayersPerLevel: 1,
                        baseCardsPerLayer: 12,
                        obstacleRate: 0.2,
                        cardTypes: [
                            'üêë', 'üåæ', 'üå±', 'üåº', 'üå≥', '‚òÄÔ∏è', 
                            'üåô', '‚≠ê', 'üíß', 'üî•', 'üåµ', 'üçÑ',
                            'üêî', 'üêÑ', 'ü•ï', 'üåΩ', 'üçÉ', 'üåπ'
                        ],
                        obstacleTypes: ['ü™®', 'üåë', '‚õ∞Ô∏è'],
                        encouragements: [
                            "Â§™Áâõ‰∫ÜÔºÅËøôÂÖ≥ÂØπ‰Ω†Êù•ËØ¥ÁÆÄÁõ¥Â∞èËèú‰∏ÄÁ¢üÔºÅ",
                            "È´òÊâãÂïäÔºÅ‰Ω†ÁöÑËßÇÂØüÂäõ‰πüÂ§™ÊïèÈîê‰∫ÜÂêßÔºÅ",
                            "ÂÆåÂÖ®ÊòØÊ∂àÈô§Â§ßÂ∏àÔºÅ‰∏ã‰∏ÄÂÖ≥ÂáÜÂ§áÂ•ΩËøéÊé•ÊåëÊàò‰∫ÜÂêóÔºü",
                            "Â§™ÂéâÂÆ≥‰∫ÜÔºÅÊØè‰∏ÄÂÖ≥ÈÉΩËÉΩËΩªÊùæÊãø‰∏ãÔºå‰Ω©Êúç‰Ω©ÊúçÔºÅ",
                            "ËäÇÂ•èÊéåÊè°ÂæóÂàöÂàöÂ•ΩÔºåÁªßÁª≠‰øùÊåÅËøô‰∏™Áä∂ÊÄÅÔºÅ",
                            "Ê≤°ÊÉ≥Âà∞Ëøô‰πàÂø´Â∞±ÈÄöÂÖ≥‰∫ÜÔºå‰Ω†ÊòØ‰∏çÊòØÂÅ∑ÂÅ∑ÁªÉËøáÔºü",
                            "ËøôÊìç‰ΩúÂ§™‰∏ùÊªë‰∫ÜÔºÅÊúüÂæÖ‰Ω†‰∏ã‰∏ÄÂÖ≥ÁöÑË°®Áé∞ÔºÅ",
                            "‰∏çÊÑßÊòØ‰Ω†ÔºÅÈöæÂ∫¶ÂçáÁ∫ß‰πüÊå°‰∏ç‰Ωè‰Ω†ÁöÑËÑöÊ≠•ÔºÅ",
                            "Â§™Á≤æÂΩ©‰∫ÜÔºÅÊØè‰∏ÄÊ≠•ÈÉΩÊÅ∞Âà∞Â•ΩÂ§ÑÔºåÂÆåÁæéÔºÅ",
                            "Â∑≤ÁªèÂºÄÂßãÊúüÂæÖ‰Ω†ËÉΩÈóØÂà∞Â§öÂ∞ëÂÖ≥‰∫ÜÔºåÂä†Ê≤πÔºÅ"
                        ],
                        newRecordEncouragements: [
                            "üéâ Êñ∞Á∫™ÂΩïÔºÅ‰Ω†ÊòØÊ∏∏Êàè‰πãÁéãÔºÅüéâ",
                            "üèÜ ÂéÜÂè≤ÊúÄ‰Ω≥ÔºÅÈöæ‰ª•ÁΩÆ‰ø°ÁöÑË°®Áé∞ÔºÅüèÜ",
                            "üåü Á™ÅÁ†¥ÊûÅÈôêÔºÅ‰Ω†ÂàõÈÄ†‰∫ÜÊñ∞ÁöÑÈ´òÂ∫¶ÔºÅüåü",
                            "üî• ‰º†Â•áËØûÁîüÔºÅËøô‰∏™Á∫™ÂΩï‰ºöË¢´Èì≠ËÆ∞ÔºÅüî•",
                            "üí™ Â§™Âº∫‰∫ÜÔºÅ‰Ω†Â∑≤ÁªèË∂ÖË∂ä‰∫ÜËá™Â∑±ÔºÅüí™",
                            "üëè ‰∏çÂèØÊÄùËÆÆÔºÅËøôÊòØÂéÜÂè≤ÊÄßÁöÑÊó∂ÂàªÔºÅüëè",
                            "‚≠ê ÊòüÂÖâÈó™ËÄÄÔºÅ‰Ω†ÊòØÁúüÊ≠£ÁöÑÂÜ†ÂÜõÔºÅ‚≠ê",
                            "üéä ËÆ∞ÂΩïÂà∑Êñ∞ÔºÅ‰Ω†ÊòØÊ∏∏ÊàèÁöÑÁªüÊ≤ªËÄÖÔºÅüéä",
                            "üéØ ÂÆåÁæéË°®Áé∞ÔºÅÊñ∞ÁöÑÁ∫™ÂΩïÂ±û‰∫é‰Ω†ÔºÅüéØ",
                            "‚ú® ‰Ω†ÂÅöÂà∞‰∫ÜÔºÅÂéÜÂè≤Êñ∞È´òÔºÅÊú™Êù•ÂèØÊúüÔºÅ‚ú®"
                        ],
                        gameRules: [
                            "1. ÁÇπÂáªÂç°ÁâáÂ∞ÜÂÖ∂ÊîæÂÖ•‰∏ãÊñπÂç°ÊßΩ",
                            "2. ÂΩìÂç°ÊßΩ‰∏≠Êúâ3Âº†Áõ∏ÂêåÂõæÊ°àÁöÑÂç°ÁâáÊó∂ÔºåÂÆÉ‰ª¨Â∞ÜË¢´Ëá™Âä®Ê∂àÈô§",
                            "3. ÊØèÂº†Âç°ÁâáÊúÄÂ§öÂè™ËÉΩË¢´ÁÇπÂáª1Ê¨°",
                            "4. Ê∂àÈô§ÊâÄÊúâÂç°ÁâáÂç≥ÂèØÈÄöÂÖ≥",
                            "5. Âç°ÊßΩÊúÄÂ§öÂèØÂÆπÁ∫≥7Âº†Âç°ÁâáÔºåÊª°‰∫ÜÂàôÊó†Ê≥ïÁªßÁª≠ÈÄâÊã©",
                            "6. ÊØèÂÖ≥Êúâ2Ê¨°ÈáçÊéíÊú∫‰ºöÔºåÂèØ‰ª•ÈáçÊñ∞ÊéíÂàóÈ°∂Â±ÇÂç°Áâá",
                            "7. ÊØèÂÖ≥Êúâ2Ê¨°ÁßªÈô§Êú∫‰ºöÔºåÂèØ‰ª•ÁßªÈô§Âç°ÊßΩ‰∏≠ÁöÑÊâÄÊúâÂç°Áâá",
                            "8. Âç°‰ΩèÊó∂ÂèØ‰ª•‰ΩøÁî®ÊèêÁ§∫ÂäüËÉΩÂØªÊâæÂèØÂåπÈÖçÁöÑÂç°Áâá"
                        ],
                        music: {
                            bgmPath: './haijiduoduokai.mp3',
                            volume: 0.5
                        }
                    }

                    // Ê∏∏ÊàèÁä∂ÊÄÅ
                    const gameState = reactive({
                        level: 1,
                        layers: [],
                        slots: [],
                        remainingCards: 0,
                        totalCards: 0,
                        isProcessing: false,
                        refreshCount: 2,
                        removeCount: 2,
                        personalHighScore: 0,
                        globalHighScore: 0
                    })

                    // ÁªÑ‰ª∂Áä∂ÊÄÅ
                    const gameArea = ref(null)
                    const showOverlay = ref(false)
                    const showDefeatMessage = ref(false)
                    const showVictoryMessage = ref(false)
                    const showNewRecord = ref(false)
                    const newRecordMessage = ref('')
                    const newRecordStyle = ref({})
                    const tempMessage = ref('')
                    const tempMessageOpacity = ref(0)
                    const showRules = ref(true)
                    const isSlotFull = ref(false)
                    const isSlotClearing = ref(false)
                    const encourageText = ref('')
                    const victoryEmoji = ref('üéâ')
                    const isMusicPlaying = ref(false)
                    let audio = null

                    // ËÆ°ÁÆóÂ±ûÊÄß
                    const allCards = computed(() => {
                        const cards = []
                        gameState.layers.forEach(layer => {
                            layer.forEach(card => {
                                if (!card.matched && !card.selected) {
                                    cards.push(card)
                                }
                            })
                        })
                        return cards
                    })

                    // ÂàùÂßãÂåñÈü≥‰πê
                    const initMusic = () => {
                        try {
                            audio = new Audio()
                            // ‰ΩøÁî®Ê≠£Á°ÆÁöÑÁõ∏ÂØπË∑ØÂæÑ
                            audio.src = './haijiduoduokai.mp3'
                            audio.volume = config.music.volume || 0.5
                            audio.loop = true
                            audio.paused = true
                        } catch (e) {
                            console.warn('ÂàùÂßãÂåñËÉåÊôØÈü≥‰πêÂ§±Ë¥•:', e)
                        }
                    }

                    // ÂàáÊç¢Èü≥‰πêÊí≠ÊîæÁä∂ÊÄÅ
                    const toggleMusic = () => {
                        if (!audio) {
                            initMusic()
                            return
                        }

                        try {
                            if (audio.paused) {
                                // ÂÖàËÆæÁΩÆsrcÁ°Æ‰øùÈü≥‰πêÂ∑≤Âä†ËΩΩ
                                if (!audio.src || audio.src.includes('haijiduoduokai.mp3')) {
                                    audio.src = './haijiduoduokai.mp3'; // ‰ΩøÁî®Áõ∏ÂØπË∑ØÂæÑ
                                }
                                audio.play().then(() => {
                                    isMusicPlaying.value = true
                                }).catch(error => {
                                    console.warn('Èü≥‰πêÊí≠ÊîæÂ§±Ë¥•:', error)
                                })
                            } else {
                                audio.pause()
                                isMusicPlaying.value = false
                            }
                        } catch (e) {
                            console.warn('ÂàáÊç¢Èü≥‰πêÁä∂ÊÄÅÂ§±Ë¥•:', e)
                        }
                    }

                    // Ëé∑Âèñ‰∏™‰∫∫ÊúÄÈ´òÂàÜ
                    const getPersonalHighScore = () => {
                        try {
                            const savedScore = localStorage.getItem('niulegeniu_highscore')
                            return savedScore ? parseInt(savedScore, 10) : 0
                        } catch (e) {
                            console.warn('Êó†Ê≥ïËé∑Âèñ‰∏™‰∫∫ÊúÄÈ´òÂàÜËÆ∞ÂΩï:', e)
                            return 0
                        }
                    }

                    // Êõ¥Êñ∞‰∏™‰∫∫ÊúÄÈ´òÂàÜ
                    const updatePersonalHighScore = (score) => {
                        try {
                            localStorage.setItem('niulegeniu_highscore', score.toString())
                            gameState.personalHighScore = score
                        } catch (e) {
                            console.warn('Êó†Ê≥ï‰øùÂ≠ò‰∏™‰∫∫ÊúÄÈ´òÂàÜËÆ∞ÂΩï:', e)
                        }
                    }

                    // Ëé∑ÂèñÂÖ®ÁΩëÊúÄÈ´òÂàÜ
                    const getGlobalHighScore = async () => {
                        try {
                            // Ê®°ÊãüËé∑ÂèñÂÖ®ÁêÉÊúÄÈ´òÂàÜ
                            return 10 // ÈªòËÆ§ÂÄº
                        } catch (e) {
                            console.warn('Êó†Ê≥ïËé∑ÂèñÂÖ®ÁΩëÊúÄÈ´òÂàÜËÆ∞ÂΩï:', e)
                            return 0
                        }
                    }

                    // ÊòæÁ§∫‰∏¥Êó∂Ê∂àÊÅØ
                    const showTemporaryMessage = (message, duration = 2000) => {
                        tempMessage.value = message
                        tempMessageOpacity.value = 1

                        setTimeout(() => {
                            tempMessageOpacity.value = 0
                            setTimeout(() => {
                                tempMessage.value = ''
                            }, 300)
                        }, duration)
                    }

                    // ÊòæÁ§∫Êñ∞Á∫™ÂΩïÊ∂àÊÅØ
                    const showNewRecordMessage = (isGlobalRecord = false) => {
                        if (isGlobalRecord) {
                            newRecordMessage.value = 'ÂΩìÂâçÂÖ®ÁΩëÁ¨¨‰∏Ä‰∫∫ÔºÅ'
                            newRecordStyle.value = {
                                background: 'linear-gradient(45deg, #FFD700, #FFA500)',
                                fontSize: '28px'
                            }
                        } else {
                            const randomEncourage = config.newRecordEncouragements[
                                Math.floor(Math.random() * config.newRecordEncouragements.length)
                            ]
                            newRecordMessage.value = randomEncourage
                            newRecordStyle.value = {
                                background: 'linear-gradient(45deg, #FFD700, #FFA500)',
                                fontSize: '24px'
                            }
                        }

                        showNewRecord.value = true

                        setTimeout(() => {
                            showNewRecord.value = false
                        }, 3000)
                    }

                    // ÁîüÊàêÂ§öÂ±ÇÂç°Áâá
                    const generateLayers = () => {
                        gameState.layers = []
                        gameState.remainingCards = 0
                        gameState.totalCards = 0

                        const totalLayers = config.baseLayers + (gameState.level - 1) * config.increaseLayersPerLevel
                        const cardAreaWidth = gameArea.value.clientWidth - 40
                        const cardAreaHeight = gameArea.value.clientHeight - 40
                        const cardSize = 65

                        for (let layer = 0; layer < totalLayers; layer++) {
                            const layerCards = []
                            const layerSizeRatio = 1 - (layer / totalLayers) * 0.5
                            const layerWidth = cardAreaWidth * layerSizeRatio
                            const layerHeight = cardAreaHeight * layerSizeRatio
                            const startX = (cardAreaWidth - layerWidth) / 2 + 20
                            const startY = (cardAreaHeight - layerHeight) / 2 + 20

                            const cardsInLayer = config.baseCardsPerLayer + layer * 4 + (gameState.level - 1) * 2

                            const typesCount = Math.ceil(cardsInLayer / 3)
                            const shuffledTypes = [...config.cardTypes].sort(() => 0.5 - Math.random())
                            const selectedTypes = shuffledTypes.slice(0, typesCount)

                            let typeIndex = 0
                            let typeCounter = 0

                            for (let i = 0; i < cardsInLayer; i++) {
                                const x = startX + Math.floor(Math.random() * (layerWidth - cardSize))
                                const y = startY + Math.floor(Math.random() * (layerHeight - cardSize))

                                const adjustedObstacleRate = Math.min(
                                    config.obstacleRate + (gameState.level - 1) * 0.03,
                                    0.4
                                )
                                const isObstacle = Math.random() < adjustedObstacleRate && layer < totalLayers - 1

                                let cardType
                                if (isObstacle) {
                                    cardType = config.obstacleTypes[Math.floor(Math.random() * config.obstacleTypes.length)]
                                } else {
                                    cardType = selectedTypes[typeIndex]
                                    typeCounter++
                                    if (typeCounter >= 3) {
                                        typeIndex = (typeIndex + 1) % selectedTypes.length
                                        typeCounter = 0
                                    }
                                    gameState.remainingCards++
                                    gameState.totalCards++
                                }

                                layerCards.push({
                                    id: `card-${layer}-${i}`,
                                    type: cardType,
                                    layer: layer,
                                    x: x,
                                    y: y,
                                    matched: false,
                                    selected: false,
                                    isObstacle: isObstacle,
                                    isLocked: layer < totalLayers - 1,
                                    isHinted: false,
                                    isRefreshing: false,

                                })
                            }

                            gameState.layers.push(layerCards)
                        }

                        updateTopLayerLockStatus()
                    }

                    // Ê£ÄÊü•Âç°ÁâáÊòØÂê¶Ë¢´Ë¶ÜÁõñ
                    const isCardUncovered = (layer, index) => {
                        const card = gameState.layers[layer][index]
                        const cardSize = 65
                        const cardHalf = cardSize / 2
                        const cardCenterX = card.x + cardHalf
                        const cardCenterY = card.y + cardHalf

                        for (let upperLayer = layer + 1; upperLayer < gameState.layers.length; upperLayer++) {
                            const upperCards = gameState.layers[upperLayer]

                            for (const upperCard of upperCards) {
                                if (!upperCard.matched && !upperCard.selected) {
                                    const upperCenterX = upperCard.x + cardHalf
                                    const upperCenterY = upperCard.y + cardHalf
                                    const distance = Math.hypot(cardCenterX - upperCenterX, cardCenterY - upperCenterY)

                                    if (distance < cardHalf * 0.8) {
                                        return false
                                    }
                                }
                            }
                        }

                        return true
                    }

                    // Êõ¥Êñ∞È°∂Â±ÇÂç°ÁâáÈîÅÂÆöÁä∂ÊÄÅ
                    const updateTopLayerLockStatus = () => {
                        const totalLayers = gameState.layers.length

                        for (let layer = totalLayers - 1; layer >= 0; layer--) {
                            const currentLayer = gameState.layers[layer]
                            const isTopLayer = layer === totalLayers - 1

                            currentLayer.forEach((card, index) => {
                                if (isTopLayer || isCardUncovered(layer, index)) {
                                    card.isLocked = false
                                } else {
                                    card.isLocked = true
                                }
                            })
                        }
                    }

                    // Â§ÑÁêÜÂç°ÁâáÁÇπÂáª
                    const handleCardClick = (card) => {
                        if (gameState.isProcessing) return
                        if (card.matched || card.isLocked) return

                        if (gameState.slots.length >= config.slots) {
                            isSlotFull.value = true
                            setTimeout(() => {
                                isSlotFull.value = false
                            }, 1000)
                            return
                        }


                        card.selected = true

                        // Ê∑ªÂä†Âà∞Âç°ÊßΩ
                        gameState.slots.push({ ...card, layer: card.layer, index: gameState.layers[card.layer].findIndex(c => c.id === card.id) })

                        // Ê£ÄÊü•ÊòØÂê¶ÂèØ‰ª•Ê∂àÈô§
                        checkForMatch()
                    }

                    // ‰ªéÂç°ÊßΩÁßªÈô§Âç°Áâá
                    const handleRemoveFromSlot = (slotIndex) => {
                        if (gameState.isProcessing) return

                        const card = gameState.slots[slotIndex]
                        gameState.slots.splice(slotIndex, 1)

                        // ÈáçÊñ∞ÊòæÁ§∫Âç°Áâá
                        const originalCard = gameState.layers[card.layer].find(c => c.id === card.id)
                        if (originalCard) {
                            originalCard.selected = false
                        }

                        updateTopLayerLockStatus()
                    }

                    // Ê£ÄÊü•ÊòØÂê¶ÂèØ‰ª•ÂåπÈÖç
                    const checkForMatch = () => {
                        if (gameState.slots.length < 3) return

                        const typeCounts = {}
                        gameState.slots.forEach(card => {
                            typeCounts[card.type] = (typeCounts[card.type] || 0) + 1
                        })

                        let matchType = null
                        for (const type in typeCounts) {
                            if (typeCounts[type] >= 3) {
                                matchType = type
                                break
                            }
                        }

                        if (matchType) {
                            const matchIndices = gameState.slots
                                .map((card, index) => ({ ...card, slotIndex: index }))
                                .filter(card => card.type === matchType)
                                .slice(0, 3)

                            eliminateCards(matchIndices)
                        }
                    }

                    // Ê∂àÈô§Âç°Áâá
                    const eliminateCards = (matchIndices) => {
                        gameState.isProcessing = true

                        matchIndices.forEach(item => {
                            const card = gameState.layers[item.layer][item.index]
                            card.matched = true
                            card.selected = false
                        })

                        const slotIndicesToRemove = matchIndices.map(item => item.slotIndex).sort((a, b) => b - a)
                        slotIndicesToRemove.forEach(index => {
                            gameState.slots.splice(index, 1)
                        })

                        gameState.remainingCards -= 3

                        setTimeout(() => {
                            updateTopLayerLockStatus()
                            gameState.isProcessing = false
                            checkGameStatus()
                        }, 400)
                    }

                    // Ê£ÄÊü•Ê∏∏ÊàèÁä∂ÊÄÅ
                    const checkGameStatus = () => {
                        if (gameState.remainingCards <= 0) {
                            setTimeout(() => {
                                showVictoryMessageFunc()
                            }, 500)
                            return
                        }

                        if (gameState.slots.length >= config.slots && !canEliminateAny() && !hasUnlockedCards()) {
                            showDefeatMessageFunc()
                        }
                    }

                    // Ê£ÄÊü•ÊòØÂê¶ÊúâÂèØÊ∂àÈô§ÁöÑÂç°Áâá
                    const canEliminateAny = () => {
                        const typeCounts = {}
                        gameState.slots.forEach(card => {
                            typeCounts[card.type] = (typeCounts[card.type] || 0) + 1
                        })

                        for (const type in typeCounts) {
                            if (typeCounts[type] >= 3) {
                                return true
                            }
                        }
                        return false
                    }

                    // Ê£ÄÊü•ÊòØÂê¶ÊúâÊú™ÈîÅÂÆöÁöÑÂç°Áâá
                    const hasUnlockedCards = () => {
                        const totalLayers = gameState.layers.length

                        for (let layer = 0; layer < totalLayers; layer++) {
                            const currentLayer = gameState.layers[layer]

                            for (let index = 0; index < currentLayer.length; index++) {
                                const card = currentLayer[index]
                                if (!card.matched && !card.selected) {
                                    if (layer === totalLayers - 1 || isCardUncovered(layer, index)) {
                                        return true
                                    }
                                }
                            }
                        }
                        return false
                    }

                    // ÊòæÁ§∫ËÉúÂà©Ê∂àÊÅØ
                    const showVictoryMessageFunc = () => {
                        let isNewPersonalRecord = false

                        if (gameState.level > gameState.personalHighScore) {
                            updatePersonalHighScore(gameState.level)
                            isNewPersonalRecord = true
                        }

                        let randomEncourage
                        if (isNewPersonalRecord) {
                            randomEncourage = config.newRecordEncouragements[
                                Math.floor(Math.random() * config.newRecordEncouragements.length)
                            ]
                        } else {
                            randomEncourage = config.encouragements[
                                Math.floor(Math.random() * config.encouragements.length)
                            ]
                        }

                        encourageText.value = randomEncourage
                        
                        if (isNewPersonalRecord) {
                            encourageText.value += ' <span style="color: gold; font-weight: bold;">(‰∏™‰∫∫Êñ∞Á∫™ÂΩïÔºÅ)</span>'
                        }

                        const victoryEmojis = ['üéâ', 'üèÜ', 'üåü', 'ü•≥', 'üëè', 'üí™']
                        victoryEmoji.value = victoryEmojis[Math.floor(Math.random() * victoryEmojis.length)]

                        if (isNewPersonalRecord) {
                            showNewRecordMessage(false)
                        }

                        showOverlay.value = true
                        showVictoryMessage.value = true
                    }

                    // ÊòæÁ§∫Â§±Ë¥•Ê∂àÊÅØ
                    const showDefeatMessageFunc = () => {
                        showOverlay.value = true
                        showDefeatMessage.value = true
                    }

                    // ÈáçÊñ∞ÂºÄÂßãÊ∏∏Êàè
                    const handleRestart = () => {
                        gameState.level = 1
                        initGame()
                    }

                    // ËøõÂÖ•‰∏ã‰∏ÄÂÖ≥
                    const handleNextLevel = () => {
                        gameState.level++
                        initGame()
                    }

                    // ÊòæÁ§∫ÊèêÁ§∫
                    const handleHint = () => {
                        if (gameState.isProcessing) return

                        const allUnlockedCards = []

                        gameState.layers.forEach((layer, layerIndex) => {
                            layer.forEach((card, cardIndex) => {
                                if (!card.matched && !card.selected && !card.isLocked) {
                                    allUnlockedCards.push({ ...card, layer: layerIndex, index: cardIndex })
                                }
                            })
                        })

                        const groups = {}
                        allUnlockedCards.forEach(card => {
                            if (!groups[card.type]) {
                                groups[card.type] = []
                            }
                            groups[card.type].push(card)
                        })

                        let hintGroup = null
                        for (const type in groups) {
                            if (groups[type].length >= 3) {
                                hintGroup = groups[type]
                                break
                            }
                        }

                        if (hintGroup) {
                            const hintedCards = hintGroup.slice(0, 3)

                            hintedCards.forEach(card => {
                                const originalCard = gameState.layers[card.layer][card.index]
                                if (originalCard) {
                                    originalCard.isHinted = true
                                }
                            })

                            setTimeout(() => {
                                hintedCards.forEach(card => {
                                    const originalCard = gameState.layers[card.layer][card.index]
                                    if (originalCard) {
                                        originalCard.isHinted = false
                                    }
                                })
                            }, 3000)

                            showTemporaryMessage('Â∑≤Ê†áËÆ∞ÂèØÂåπÈÖçÁöÑÂç°Áâá')
                        } else {
                            showTemporaryMessage('Ê≤°ÊúâÂèØÂåπÈÖçÁöÑÂç°ÁâáÁªÑÂêàÔºåÂ∞ùËØïÈáçÊéíÊàñÁßªÈô§Âç°ÊßΩÂç°Áâá')
                        }
                    }

                    // ÈáçÊéíÂç°Áâá
                    const handleRefresh = () => {
                        if (gameState.isProcessing || gameState.refreshCount <= 0) return

                        gameState.refreshCount--

                        const topLayerIndex = gameState.layers.length - 1
                        const topLayer = gameState.layers[topLayerIndex]
                        const unlockedCards = topLayer.filter(card => !card.matched && !card.selected && !card.isLocked && !card.isObstacle)

                        if (unlockedCards.length <= 1) {
                            showTemporaryMessage('Âç°ÁâáÂ§™Â∞ëÔºåÊó†Ê≥ïÈáçÊéí')
                            return
                        }

                        unlockedCards.forEach(card => {
                            card.isRefreshing = true
                        })

                        setTimeout(() => {
                            const cardAreaWidth = gameArea.value.clientWidth - 40
                            const cardAreaHeight = gameArea.value.clientHeight - 40
                            const cardSize = 65
                            const spacing = 10

                            const hasCollision = (newX, newY, cardIndex, positions) => {
                                const minDistance = cardSize + spacing
                                for (let i = 0; i < cardIndex; i++) {
                                    const dx = newX - positions[i].x
                                    const dy = newY - positions[i].y
                                    const distance = Math.sqrt(dx * dx + dy * dy)
                                    if (distance < minDistance) {
                                        return true
                                    }
                                }
                                return false
                            }

                            const positions = []
                            unlockedCards.forEach((card, index) => {
                                let attempts = 0
                                const maxAttempts = 50
                                let newX, newY

                                do {
                                    newX = 20 + Math.floor(Math.random() * (cardAreaWidth - cardSize))
                                    newY = 20 + Math.floor(Math.random() * (cardAreaHeight - cardSize))
                                    attempts++
                                } while (attempts < maxAttempts && hasCollision(newX, newY, index, positions))

                                card.x = newX
                                card.y = newY
                                positions.push({ x: newX, y: newY })
                                card.isRefreshing = false
                            })

                            showTemporaryMessage('Âç°ÁâáÂ∑≤ÈáçÊéí')
                        }, 300)
                    }

                    // ÁßªÈô§ÊâÄÊúâÂç°ÊßΩÂç°Áâá
                    const handleRemoveAll = () => {
                        if (gameState.isProcessing || gameState.removeCount <= 0 || gameState.slots.length === 0) {
                            if (gameState.slots.length === 0 && gameState.removeCount > 0) {
                                showTemporaryMessage('Âç°ÊßΩ‰∏∫Á©∫ÔºåÊó†ÈúÄÁßªÈô§')
                            }
                            return
                        }

                        isSlotClearing.value = true
                        gameState.removeCount--

                        const cardsToRender = [...gameState.slots]
                        gameState.slots = []

                        cardsToRender.forEach(card => {
                            const originalCard = gameState.layers[card.layer].find(c => c.id === card.id)
                            if (originalCard) {
                                originalCard.selected = false
                            }
                        })

                        updateTopLayerLockStatus()
                        showTemporaryMessage('Â∑≤ÁßªÈô§ÊâÄÊúâÂç°ÊßΩÂç°Áâá')

                        setTimeout(() => {
                            isSlotClearing.value = false
                        }, 300)
                    }

                    // ÂÖ≥Èó≠ËßÑÂàôÂºπÁ™ó
                    const closeRules = (event) => {
                        // Âè™ÊúâÂΩìÁÇπÂáªÁöÑÊòØÂºπÁ™óËÉåÊôØÊó∂ÊâçÂÖ≥Èó≠ÔºåÊàñËÄÖÊ≤°ÊúâeventÂèÇÊï∞Áõ¥Êé•ÂÖ≥Èó≠
                        if (!event || event.target.classList.contains('rules-modal')) {
                            showRules.value = false
                        }
                    }

                    // ÂºÄÂßãÊ∏∏Êàè
                    const startGame = () => {
                        closeRules()
                        initGame()
                    }

                    // ÂàùÂßãÂåñÊ∏∏Êàè
                    const initGame = () => {
                        gameState.layers = []
                        gameState.slots = []
                        gameState.remainingCards = 0
                        gameState.totalCards = 0
                        gameState.isProcessing = false
                        gameState.refreshCount = 2
                        gameState.removeCount = 2

                        showOverlay.value = false
                        showDefeatMessage.value = false
                        showVictoryMessage.value = false
                        isSlotFull.value = false

                        nextTick(() => {
                            generateLayers()
                        })
                    }

                    // ÁªÑ‰ª∂ÊåÇËΩΩÊó∂ÂàùÂßãÂåñ
                    onMounted(() => {
                        initMusic()
                        gameState.personalHighScore = getPersonalHighScore()
                        gameState.globalHighScore = 10 // ËÆæÁΩÆÈªòËÆ§ÂÄº
                    })

                    return {
                        config,
                        gameState,
                        gameArea,
                        showOverlay,
                        showDefeatMessage,
                        showVictoryMessage,
                        showNewRecord,
                        newRecordMessage,
                        newRecordStyle,
                        tempMessage,
                        tempMessageOpacity,
                        showRules,
                        isSlotFull,
                        isSlotClearing,
                        encourageText,
                        victoryEmoji,
                        isMusicPlaying,
                        allCards,
                        handleCardClick,
                        handleRemoveFromSlot,
                        handleRestart,
                        handleNextLevel,
                        handleHint,
                        handleRefresh,
                        handleRemoveAll,
                        toggleMusic,
                        closeRules,
                        startGame
                    }
                },
                template: `
                    <div class="game-container">
                        <h1>Áâõ‰∫Ü‰∏™Áâõ</h1>
                        
                        <div class="level-info">
                            <div>ÂÖ≥Âç°: {{ gameState.level }}</div>
                            <div>Ââ©‰Ωô: {{ gameState.remainingCards }}</div>
                        </div>
                        
                        <div class="game-area" ref="gameArea">
                            <div class="level-indicator">Á¨¨{{ gameState.level }}ÂÖ≥</div>
                            <!-- Âç°ÁâáÊ∏≤Êüì -->
                            <div
                                v-for="(card, index) in allCards"
                                :key="card.id"
                                class="card"
                                :class="{
                                    'locked': card.isLocked,
                                    'obstacle': card.isObstacle,
                                    'matched': card.matched,
                                    'selected': card.selected,
                                    'hint-animation': card.isHinted,
                                    'refreshing': card.isRefreshing
                                }"
                                :style="{
                                    left: card.x + 'px',
                                    top: card.y + 'px',
                                    zIndex: card.layer + 1
                                }"
                                  @click="handleCardClick(card)"
                              >
                                  {{ card.type }}
                              </div>
                        </div>
                        
                        <div class="card-slot" :class="{ 'slot-full': isSlotFull, 'slot-clearing': isSlotClearing }">
                            <div
                                v-for="(card, index) in gameState.slots"
                                :key="'slot-' + index"
                                class="slot-card"
                                @click="handleRemoveFromSlot(index)"
                            >
                                {{ card.type }}
                            </div>
                        </div>
                        
                        <div class="controls">
                            <button @click="handleRestart">ÈáçÊñ∞ÂºÄÂßã</button>
                            <button class="secondary" @click="handleHint" :disabled="gameState.isProcessing">ÊèêÁ§∫</button>
                            <button class="secondary" @click="handleRefresh" :disabled="gameState.refreshCount <= 0 || gameState.isProcessing">
                                ÈáçÊéí({{ gameState.refreshCount }})
                            </button>
                            <button class="secondary" @click="handleRemoveAll" :disabled="gameState.removeCount <= 0 || gameState.slots.length === 0 || gameState.isProcessing">
                                ÁßªÈô§({{ gameState.removeCount }})
                            </button>
                        </div>
                        
                        <!-- Èü≥‰πêÊéßÂà∂ÊåâÈíÆ -->
                        <button class="music-control-btn" @click="toggleMusic" title="Èü≥‰πêÊéßÂà∂">
                            {{ isMusicPlaying ? 'üîä' : 'üîá' }}
                        </button>
                        
                        <!-- ÊúÄÈ´òÂàÜÊòæÁ§∫ -->
                        <div class="high-score">üèÜ Âçï‰∫∫ÊúÄÈ´ò: {{ gameState.personalHighScore }}ÂÖ≥</div>
                        <div class="global-high-score">üåè ÂÖ®ÁΩëÊúÄÈ´ò: {{ gameState.globalHighScore }}ÂÖ≥</div>
                        
                        <!-- Ë¶ÜÁõñÂ±Ç -->
                        <div v-if="showOverlay" class="overlay"></div>
                        
                        <!-- Â§±Ë¥•Ê∂àÊÅØ -->
                        <div v-if="showDefeatMessage" class="message" @click.stop>
                            <h2>üò¢ Â§±Ë¥•</h2>
                            <p>ËØ∑ÈáçÊñ∞ÂºÄÂßã</p>
                            <button @click="handleRestart">ÂÜçÊù•‰∏ÄÂ±Ä</button>
                        </div>
                        
                        <!-- ËÉúÂà©Ê∂àÊÅØ -->
                        <div v-if="showVictoryMessage" class="message victory" @click.stop>
                            <h2>üèÜ ÈÄöÂÖ≥ÊàêÂäü</h2>
                            <div class="emoji">{{ victoryEmoji }}</div>
                            <div class="level-badge">Â∑≤ÂÆåÊàêÁ¨¨ {{ gameState.level }} ÂÖ≥</div>
                            <p v-html="encourageText"></p>
                            <button @click="handleNextLevel">ÁªßÁª≠ÊåëÊàò</button>
                        </div>
                        
                        <!-- Êñ∞Á∫™ÂΩïÊ∂àÊÅØ -->
                        <div v-if="showNewRecord" class="new-record" :style="newRecordStyle">
                            {{ newRecordMessage }}
                        </div>
                        
                        <!-- ‰∏¥Êó∂Ê∂àÊÅØ -->
                        <div v-if="tempMessage" class="game-message" :style="{ opacity: tempMessageOpacity }">
                            {{ tempMessage }}
                        </div>
                        
                        <!-- Ê∏∏ÊàèËßÑÂàôÂºπÁ™ó -->
                        <div v-if="showRules" class="rules-modal" @click="closeRules">
                            <div class="rules-content" @click.stop>
                                <h2>üêë Áâõ‰∫Ü‰∏™ÁâõÊ∏∏ÊàèËßÑÂàô üéÆ</h2>
                                <ul>
                                    <li v-for="(rule, index) in config.gameRules" :key="index">
                                        {{ rule }}
                                    </li>
                                </ul>
                                <button @click="startGame">ÂºÄÂßãÊ∏∏Êàè</button>
                            </div>
                        </div>
                    </div>
                `
            })

            app.mount('#app')
        </script>
    </body>
</html>